- 알고리즘 문제를 풀기전에 해당하는 수학공식이 있는지 찾아보는 것이 좋다.

- 재귀함수를 쓸 때는 항상 두 경우가 있어야 합니다.
- base case: 더 이상 문제를 쪼갤 필요가 없는 종료된 경우
- recursive case: 문제를 쪼개서 풀어가는 경우

```js
// 등차
let n = 100;
console.log((n * (n + 1)) / 2); //5050
```

### 재귀 함수

- 함수가 자신을 다시 호출하는 구조로 만들어진 함수이다. 재귀함수는 종료조건이 있어야 하며.
- 종료조건을 설정해주지 않으면 무한 반복을 하게된다. 재귀함수로 작성이 되는 코드는 반복문으로도 작성할 수 있다.

```js
function f(n) {
  if (n <= 1) {
    return 1; // 종료 조건
  }
  return n + f(n - 1); // 재귀함수
}
console.log(f(100)); //5050
// 재귀함수
// 순번   f(n)   n      return       최종
// 1   f(100)  100  100 + f(99)  100+99+98+97+96+95+94..+2+1
// 2   f(99)   99   99 + f(98)   99+98+97+96+95+94..+2+1
// 3   f(98)   98   98 + f(97)   98+97+96+95+94..+2+1
// 4   f(97)   97   97 + f(96)   97+96+95+94..+2+1
// ...
// 2   f(2)    2    2 + f(1)    2+1
// 1  f(1)    1    1 // return값이 자기 자신을 호출하지 않는 상황
```

- https://velog.io/@jeongin/Javascript-%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98

```js
let a = 1;
let b = 1;
for (var i = 0; i < 6; i++) {
  let c = a + b;
  a = b;
  b = c;
}
console.log(b); // 21

function 피보나치(숫자) {
  if (숫자 == 1 || 숫자 == 2) {
    return 1;
  }
  return 피보나치(숫자 - 1) + 피보나치(숫자 - 2);
}
console.log(피보나치(5));
// 피보나치(5) 피보나치(4) + 피보나치(3) -> 3+2
// 피보나치(4) 피보나치(3) + 피보나치(2) -> 2+1
// 피보나치(3) 피보나치(2) + 피보나치(1) -> 1+1
// 피보나치(2) -> 1
// 피보나치(1) -> 1
// f(f(f(f(2) + f(1)) + f(2)) + f(f(2) + f(1)))
// 재귀로 하였을 때 효율이 떨어짐 f(2)를 계속해서 더하고 있다.
```

```js
function f(n) {
  if (n <= 1) {
    // base case
    return 1;
  }
  return n + f(n - 1); // recursive case
}
console.log(f(4)); //결과값 10

// 재귀패턴 순서 설명
// return    최종
//4 + f(3)   4 + 3 + 2 + 1
//3 + f(2)   3 + 2 + 1
//2 + f(1)   2 + 1
//1 + f(1)   1 (base case에 걸린 경우)
```

- https://triplexlab.tistory.com/163
